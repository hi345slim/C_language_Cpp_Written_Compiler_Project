
# **C-Language Frontend: A Modular Compiler Project**

This project provides the first two major phases of a compiler for a subset of the C programming language: a **Lexical Analyzer (Scanner)** and a **Syntactic Analyzer (Parser)**. The system is designed as a modular toolchain, where the scanner produces a stream of tokens that the parser consumes.

## **Project Overview**

The goal of this project is to analyze C source code to validate its lexical and syntactic structure. It is an educational tool designed to demonstrate the core principles of compiler construction.

-   **Phase 1: The Scanner (`scanner.exe`)**
    -   Reads a `.c` source file.
    -   Performs lexical analysis to break the source code into a stream of tokens.
    -   Handles keywords, identifiers, numeric constants, operators, and special characters.
    -   Correctly identifies and tokenizes single-line (`//`) and multi-line (`/* ... */`) comments.
    -   Outputs the token stream to a file named `tokens.txt`.

-   **Phase 2: The Parser (`parser.exe`)**
    -   Reads the `tokens.txt` file generated by the scanner.
    -   Performs syntactic analysis using a **top-down, LL(1), recursive-descent** strategy.
    -   Validates the token stream against a formal grammar.
    -   If the code is syntactically valid, it reports success.
    -   If a syntax error is found, it reports a **detailed error message**, including the **line number** and the nature of the error, then halts.

## **Features**

-   **Modular Design:** The scanner and parser are separate, standalone executables that communicate via a well-defined token file (`tokens.txt`).
-   **Robust Error Reporting:** The parser provides clear, actionable error messages, pinpointing the exact location of any syntax errors in the original source code.
-   **Comprehensive Grammar:** The parser supports a significant subset of C, including global/local variable declarations, constants, functions, `if-else` statements, `for` loops, and complex expressions.
-   **Extensible Codebase:** The recursive-descent implementation is clear and easy to extend with new language features.

## **How to Compile and Run the Toolchain**

### **Prerequisites**

-   A C++ compiler that supports the C++11 standard or later (e.g., g++, Clang, MSVC).

### **Compilation**

Open a terminal or command prompt in the project's root directory and run the following commands:

```sh
# Compile the scanner
g++ scanner.cpp -std=c++11 -o scanner

# Compile the parser
g++ parser.cpp -std=c++11 -o parserThis will produce two executables: scanner.exe and parser.exe.
Workflow

The toolchain operates in a two-step process.

    Run the Scanner

    Execute the scanner and provide it with your C source file.
    code Sh

    
./scanner

  

The program will prompt you for the location of the .c file. Upon successful completion, it will create a tokens.txt file in the same directory.

Run the Parser

Execute the parser. It will automatically read and analyze the tokens.txt file.
code Sh

        
    ./parser

      

    The parser will then output its analysis to the console, reporting either success or the first syntax error it encounters.

Supported Grammar

The parser validates code based on the following formal LL(1) grammar.

Notation: * = 0 or more, ? = optional, | = OR, terminals are in single quotes or uppercase.
code Ebnf

    
#### Top-Level Structure

program                 ->  top_level_declaration* EOF

top_level_declaration   ->  function_definition
                        |   variable_declaration
                        |   function_prototype
                        |   PREPROCESSOR_DIRECTIVE


#### Functions

function_definition     ->  type_specifier IDENTIFIER '(' parameter_list? ')' block_statement
function_prototype      ->  type_specifier IDENTIFIER '(' parameter_list? ')' ';'

parameter_list          ->  parameter ( ',' parameter )*
parameter               ->  type_specifier IDENTIFIER


#### Statements

statement               ->  variable_declaration
                        |   expression_statement
                        |   if_statement
                        |   for_statement
                        |   block_statement
                        |   return_statement
                        |   ';'                   // Empty statement

statement_list          ->  statement*

block_statement         ->  '{' statement_list '}'

if_statement            ->  'if' '(' expression ')' statement ( 'else' statement )?

for_statement           ->  'for' '(' for_initializer for_condition for_increment ')' statement
for_initializer         ->  variable_declaration | expression_statement
for_condition           ->  expression? ';'
for_increment           ->  expression?

return_statement        ->  'return' expression? ';'


#### Declarations & Expressions

variable_declaration    ->  'const'? type_specifier identifier_list ('=' expression)? ';'

expression_statement    ->  expression ';'

expression              ->  assignment
assignment              ->  equality ( '=' assignment )?
equality                ->  relational ( ( '==' | '!=' ) relational )*
relational              ->  additive ( ( '<' | '>' | '<=' | '>=' ) additive )*
additive                ->  multiplicative ( ( '+' | '-' ) multiplicative )*
multiplicative          ->  primary ( ( '*' | '/' ) primary )*
primary                 ->  IDENTIFIER
                        |   NUMERIC_CONSTANT
                        |   '(' expression ')'


#### Helper Rules

type_specifier          ->  'int' | 'float' | 'char' | 'void'
identifier_list         ->  IDENTIFIER ( ',' IDENTIFIER )*

  

Instructions to create the file:

    Click the "Copy" icon in the top-right corner of the code block above.

    Open a plain text editor (like Notepad on Windows, TextEdit on Mac, or VS Code).

    Paste the content into the new, empty file.

    Save the file with the exact name README.md in your project directory.

This will give you the correctly formatted file.