# C-Language Compiler Frontend: Scanner & Parser

<p align="center">
  <img src="https://user-images.githubusercontent.com/1021432/194519989-137b0185-3c48-4226-8968-3e5b303498b3.png" alt="Compiler Icon" width="150">
</p>

<p align="center">
  <strong>A modular, two-phase compiler frontend for a significant subset of the C language.</strong>
  <br />
  This project features a standalone lexical analyzer (scanner) and a robust syntactic analyzer (parser)
  <br />
  built to demonstrate the core principles of modern compiler construction.
</p>

---

## **Table of Contents**

1.  [Project Overview](#1-project-overview)
2.  [Core Features](#2-core-features)
3.  [How to Compile and Run](#3-how-to-compile-and-run)
4.  [The Formal Grammar](#4-the-formal-grammar)
5.  [Output: The Abstract Syntax Tree](#5-output-the-abstract-syntax-tree)

## **1. Project Overview**

This project provides the first two major phases of a C compiler, designed as a modular and communicative toolchain. It serves as a powerful educational tool for understanding how source code is processed and validated before compilation.

### **Phase 1: The Scanner (`scanner.exe`)**

The scanner is the first stage, responsible for **lexical analysis**. It reads raw `.c` source code and deconstructs it into a flat stream of meaningful tokens.

-   **Input:** A C source code file (`.c`).
-   **Process:** Groups characters into lexemes and classifies them into token types (Keywords, Identifiers, Operators, etc.). It correctly handles whitespace and is intelligent enough to count line numbers accurately, even across multi-line comments.
-   **Output:** A `tokens.txt` file, where each line represents a single token, its value, and its line number in the original source file. This file serves as the formal interface to the parser.

### **Phase 2: The Parser (`parser.exe`)**

The parser is the second stage, responsible for **syntactic analysis**. It consumes the token stream generated by the scanner and verifies if the sequence conforms to the formal grammar of the C language.

-   **Input:** The `tokens.txt` file.
-   **Process:** Implements a **Top-Down, Predictive, Recursive-Descent** strategy. It intelligently uses lookahead to resolve LL(1) grammar conflicts (e.g., distinguishing between a variable declaration and a function prototype).
-   **Output:**
    1.  A definitive judgment on whether the source code is **syntactically valid**.
    2.  If an error is found, a **precise, located error message** (e.g., `[Line 45] Syntax Error: Expected ';' after statement`).
    3.  On success, a beautifully formatted **Abstract Syntax Tree (AST)** is printed to the console, visualizing the entire grammatical structure of the program.

## **2. Core Features**

-   ✅ **Modular Toolchain Architecture:** Separate executables for scanner and parser, promoting clean design and separation of concerns.
-   ✅ **Comprehensive Lexical Analysis:** Handles all standard C tokens, including a full set of operators, keywords, and both `//` and `/* ... */` comments.
-   ✅ **Robust Line Number Tracking:** Accurately tracks line numbers across all constructs, including multi-line comments, ensuring precise error reporting.
-   ✅ **Advanced Recursive-Descent Parsing:** A hand-written parser that demonstrates classic techniques for handling operator precedence and resolving grammatical ambiguities with lookahead.
-   ✅ **High-Quality Error Reporting:** On failure, the parser provides clear, actionable feedback, pinpointing the exact location of the syntax error.
-   ✅ **Full AST Visualization:** On success, the parser generates a complete and intuitive diagram of the program's hierarchical structure.
-   ✅ **Extensive Grammar Support:** The parser can handle a wide range of C constructs, including nested control flow, complex expressions, and varied declaration styles.

## **3. How to Compile and Run**

### **Prerequisites**

-   A C++ compiler supporting the C++11 standard or later (e.g., `g++`, `clang`, `msvc`).

### **Compilation**

Navigate to the project's root directory in your terminal and execute the following commands:

```sh
# 1. Compile the scanner
g++ scanner.cpp -std=c++11 -o scanner

# 2. Compile the parser
g++ C_lange_Parser_in_Cpp.cpp -std=c++11 -o parser