
# C-Language Compiler Frontend: Scanner & Parser

<p align="center">
  <img src="https://user-images.githubusercontent.com/1021432/194519989-137b0185-3c48-4226-8968-3e5b303498b3.png" width="150">
</p>

<p align="center">
  <strong>A modular, two-phase compiler frontend for a significant subset of the C language.</strong>
  <br />
  This project features a standalone lexical analyzer (scanner) and a robust syntactic analyzer (parser)
  <br />
  built to demonstrate the core principles of modern compiler construction.
</p>

---

## **Table of Contents**

-   [1. Project Overview](#1-project-overview)
-   [2. Core Features](#2-core-features)
-   [3. How to Compile and Run](#3-how-to-compile-and-run)
-   [4. The Formal Grammar](#4-the-formal-grammar)
-   [5. Output: The Abstract Syntax Tree](#5-output-the-abstract-syntax-tree)

## **1. Project Overview**

This project provides the first two major phases of a C compiler, designed as a modular and communicative toolchain. It serves as a powerful educational tool for understanding how source code is processed and validated before compilation.

### **Phase 1: The Scanner (`scanner.exe`)**

The scanner is the first stage, responsible for **lexical analysis**. It reads raw `.c` source code and deconstructs it into a flat stream of meaningful tokens.

-   **Input:** A C source code file (`.c`).
-   **Process:** Groups characters into lexemes and classifies them into token types (Keywords, Identifiers, Operators, etc.). It correctly handles whitespace and is intelligent enough to count line numbers accurately, even across multi-line comments.
-   **Output:** A `tokens.txt` file, where each line represents a single token, its value, and its line number in the original source file. This file serves as the formal interface to the parser.

### **Phase 2: The Parser (`parser.exe`)**

The parser is the second stage, responsible for **syntactic analysis**. It consumes the token stream generated by the scanner and verifies if the sequence conforms to the formal grammar of the C language.

-   **Input:** The `tokens.txt` file.
-   **Process:** Implements a **Top-Down, Predictive, Recursive-Descent** strategy. It intelligently uses lookahead to resolve LL(1) grammar conflicts (e.g., distinguishing between a variable declaration and a function prototype).
-   **Output:**
    1.  A definitive judgment on whether the source code is **syntactically valid**.
    2.  If an error is found, a **precise, located error message** (e.g., `[Line 45] Syntax Error: Expected ';' after statement`).
    3.  On success, a beautifully formatted **Abstract Syntax Tree (AST)** is printed to the console, visualizing the entire grammatical structure of the program.

## **2. Core Features**

-   ✅ **Modular Toolchain Architecture:** Separate executables for scanner and parser, promoting clean design and separation of concerns.
-   ✅ **Comprehensive Lexical Analysis:** Handles all standard C tokens, including a full set of operators, keywords, and both `//` and `/* ... */` comments.
-   ✅ **Robust Line Number Tracking:** Accurately tracks line numbers across all constructs, including multi-line comments, ensuring precise error reporting.
-   ✅ **Advanced Recursive-Descent Parsing:** A hand-written parser that demonstrates classic techniques for handling operator precedence and resolving grammatical ambiguities with lookahead.
-   ✅ **High-Quality Error Reporting:** On failure, the parser provides clear, actionable feedback, pinpointing the exact location of the syntax error.
-   ✅ **Full AST Visualization:** On success, the parser generates a complete and intuitive diagram of the program's hierarchical structure.
-   ✅ **Extensive Grammar Support:** The parser can handle a wide range of C constructs, including nested control flow, complex expressions, and varied declaration styles.

## **3. How to Compile and Run**

### **Prerequisites**

-   A C++ compiler supporting the C++11 standard or later (e.g., `g++`, `clang`, `msvc`).

### **Compilation**

Navigate to the project's root directory in your terminal and execute the following commands:

```sh
# 1. Compile the scanner
g++ scanner.cpp -std=c++11 -o scanner

# 2. Compile the parser
g++ C_lange_Parser_in_Cpp.cpp -std=c++11 -o parser
Workflow

The toolchain operates in a sequential, two-step process.

Step 1: Generate Tokens with the Scanner

Run the scanner executable. It will prompt you for the path to your .c source file.

code
Sh
download
content_copy
expand_less
./scanner

This will produce a tokens.txt file in the current directory.

Step 2: Validate Syntax with the Parser

Run the parser executable. It will automatically find and process the tokens.txt file.

code
Sh
download
content_copy
expand_less
./parser

The parser will output its analysis to the console, reporting either a success message and the AST, or the first syntax error it encounters.

4. The Formal Grammar

The parser is built to validate the following formal grammar, which covers a substantial and functional subset of the C language. The grammar is designed to be parsed by a predictive LL(k) parser.

Notation: * = 0 or more, ? = optional, | = OR, terminals are in UPPERCASE or 'single quotes'.

code
Ebnf
download
content_copy
expand_less
### Top-Level Structure

program                 ->  top_level_declaration* EOF

top_level_declaration   ->  function_definition
                        |   variable_declaration
                        |   function_prototype
                        |   PREPROCESSOR_DIRECTIVE

### Functions

function_definition     ->  type_specifier IDENTIFIER '(' parameter_list? ')' block_statement
function_prototype      ->  type_specifier IDENTIFIER '(' parameter_list? ')' ';'

parameter_list          ->  parameter ( ',' parameter )*
parameter               ->  type_specifier IDENTIFIER

### Statements

statement               ->  variable_declaration
                        |   expression_statement
                        |   if_statement
                        |   for_statement
                        |   block_statement
                        |   return_statement
                        |   ';'                   // Empty statement

statement_list          ->  statement*

block_statement         ->  '{' statement_list '}'

if_statement            ->  'if' '(' expression ')' statement ( 'else' statement )?

for_statement           ->  'for' '(' for_initializer for_condition for_increment ')' statement
for_initializer         ->  variable_declaration | expression_statement
for_condition           ->  expression? ';'
for_increment           ->  expression?

return_statement        ->  'return' expression? ';'

### Declarations

variable_declaration    ->  'const'? type_specifier declarator (',' declarator)* ';'
declarator              ->  IDENTIFIER ('=' expression)?

### Expressions (with Operator Precedence)

expression_statement    ->  expression ';'

expression              ->  assignment
assignment              ->  equality ( '=' assignment )?
equality                ->  relational ( ( '==' | '!=' ) relational )*
relational              ->  additive ( ( '<' | '>' | '<=' | '>=' ) additive )*
additive                ->  multiplicative ( ( '+' | '-' ) multiplicative )*
multiplicative          ->  primary ( ( '*' | '/' ) primary )*
primary                 ->  IDENTIFIER
                        |   NUMERIC_CONSTANT
                        |   '(' expression ')'

### Helper Rules

type_specifier          ->  'int' | 'float' | 'char' | 'void'
5. Output: The Abstract Syntax Tree

Upon successfully parsing a valid C file, the parser will render a complete Abstract Syntax Tree. This visualization provides a clear, hierarchical view of the program's structure, confirming that every statement and expression has been correctly understood.

Example Output for a complex function:
code
Code
download
content_copy
expand_less
--- Abstract Syntax Tree ---
└── Program () [Line: 5]
    ├── PreprocessorDirective (#include <stdio.h>) [Line: 5]
    └── FunctionDefinition (main) [Line: 6]
        ├── TypeSpecifier (int) [Line: 6]
        └── BlockStatement ({}) [Line: 6]
            ├── VariableDeclarationStatement () [Line: 7]
            │   ├── TypeSpecifier (int) [Line: 7]
            │   ├── Declarator (x) [Line: 7]
            │   └── Declarator (y) [Line: 7]
            ├── IfStatement (if) [Line: 41]
            │   ├── BinaryExpression (==) [Line: 41]
            │   │   ├── Identifier (x) [Line: 41]
            │   │   └── Constant (42) [Line: 41]
            │   ├── BlockStatement ({}) [Line: 41]
            │   │   ├── ExpressionStatement () [Line: 43]
            │   │   │   └── AssignmentExpression (=) [Line: 43]
            │   │   │       ├── Identifier (x) [Line: 43]
            │   │   │       └── BinaryExpression (-) [Line: 43]
            │   │   │           ├── Identifier (x) [Line: 43]
            │   │   │           └── Constant (3) [Line: 43]
            │   │   └── VariableDeclarationStatement () [Line: 44]
            │   │       ├── TypeSpecifier (int) [Line: 44]
            │   │       └── Declarator (_xyzw) [Line: 44]
            │   └── BlockStatement ({}) [Line: 45]
            │       └── ExpressionStatement () [Line: 46]
            │           └── AssignmentExpression (=) [Line: 46]
            │               ├── Identifier (y) [Line: 46]
            │               └── Constant (3.1) [Line: 46]
            └── ReturnStatement (return) [Line: 66]
                └── Constant (0) [Line: 66]
--------------------------```